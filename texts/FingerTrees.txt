UTF-8

 В пакете Data.FingerTree структура FingerTree определена следующим образом(восклицательные 
знаки указывают на то что значение хранится строго - не лениво, т.е. при применении 
конструктора сначала будут вычислены аргументы):
data FingerTree v a
	= Empty
	| Single a
	| Deep !v !(Digit a) (FingerTree v (Node v a)) !(Digit a)
data Node v a = Node2 !v a a | Node3 !v a a a
	deriving Show
data Digit a
    = One a
    | Two a a
    | Three a a a
    | Four a a a a
    deriving Show

Т.о. FingerTree хранящее элементы типа "а" - это дерево, которое хранит:
- либо ничего
- либо единственный элемент типа "а"
- либо структуру:
     - от 1 до 4 элементов типа "а" слева
	 - FingerTree хранящее элементы типа (2 или 3 элемента типа "а")
     - от 1 до 4 элементов типа "а" справа

Значение "v" не имеет прямого отношения к структуре дерева.
Предполагается, что любое значение "а" может быть вычислено в моноид "v"(Т.е. "измерено")
-- | Things that can be measured.
class (Monoid v) => Measured v a | a -> v where
    measure :: a -> v

Хранение значения v дает возможность за O(1) получить значение свернутого дерева, 
где каждый элемент дерева отображен через функцию measure.

Кроме этого, чем ещё хороша такая структура?
 -Вставка элемента в конец/начало за O(1)
 -Конкатенация 2х деревьев за O(log(min(n1,n2)))
 -Деструктурирование на (первый : остальные) за O(1)
 -Деструктурирование на (последний : всеКромеПоследнего) за O(1)
 -Разбиение по предикату на 2 поддерева за O(log(min(n1,n2)))

 Допустим необходимо ограничиться окном "данные за последний час", тогда все что 
нужно сделать - это определить measure как функцию, которая вычисляет время из 
записи(все входящие данные Timable, поэтому эта задача не составит труда), и возвращает время обернутое стандартным 
моноидом Data.Monoid.Last
 Если нужно по количеству записей, то measure будет возвращать моноид Sum 1.
Разумеется можно брать произвольно ограниченное окно. Подробнее расписано в Window.lhs

Небольшая иллюстрация того, как работает дерево может быть:
./GPS-stream/sandbox/FingerTreeViewer/FTViewer.hs
Лог использования в файле:
./GPS-stream/sandbox/FingerTreeViewer/log.txt

--------------------------------------------------------------------------------
Ссылки:
http://hackage.haskell.org/packages/archive/fingertree/latest/doc/html/src/Data-FingerTree.html                    

-- utf-8
-- нужен ли projection?

<<n>> - сноска n

<<1>>Соблюдение законов классов так же необходимо, тк компилятор может оптимизировать код используя эти законы, т.к. многие оформлены как прагма
{-# RULES ... #-}
Несоблюдение может привести к трудноуловимым багам.

<<3>>Hask - категория, объектами которой являются типы хаскеля, а морфизмами - функции хаскеля.
Тогда композиция морфизмов - композиция функций, она ассоциативна. 
Учитывая что по определению каждому морфизму категории должна соотвествовать единственная пара объектов,
Морфизм id над типом А - функция (id :: A -> A).

В модуле Control.Category имеется соотвествующее определение категории для функций.

<<2>> учитывая что в хаскеле нет функций от многих аргументов, именно такой тип и должен иметь fmap, скобки опускаются лишь для удобства чтения и за счет правоассоциативности "->"

--------------------------------------------------------------------------------
--------------------   Стандартные  классы   -----------------------------------
--------------------------------------------------------------------------------
Классы Show, Read

Любой тип, реализующий класс Show может быть преобразован в строку. Это и отражено в определении:

class Show a where
    show      :: a -> String
    showsPrec :: Int -> a -> ShowS
    showList  :: [a] -> ShowS

У каждого класса имеется минимальное полное определение. В данном случае это show или showsPrec. Это означает, что остальные методы могут быть реализованы с помощью определенных методов(хотя и для эффективности могут быть определены программистом явно). Определения по умолчанию Show:
    show x          = showsPrec 0 x ""
    showsPrec _ x s = show x ++ s
Т.к. оба метода определены друг через друга, не определив ни один метод, попадем в бесконечную взаимную рекурсию.

тип ShowS это просто синоним функции из строки в строку:
type ShowS = String -> String

Аналогично и
class Read a where
    readsPrec :: Int -> ReadS a
    readList  :: ReadS [a]
минимальное полное определение: readsPrec

тип ReadS это функция принимающая строку, возвращающая список возможных способов разбора тип данных и оставшихся после этого строк:
type ReadS a = String -> [(a, String)]

Эти классы используются, как правило, для целей ввода-вывода и представляют собой человеко-читабельную сериализацию.
Для большинства пользовательских классов они могут быть определены автоматически.

--------------------------------------------------------------------------------
Класс Functor
 Класс представляет собой контейнер, такой что к каждому элементу контейнера может быть применена функция.
Посмотрим на определение:

class Functor f where
    fmap :: (a -> b) -> f a -> f b

С одной стороны можно думать как о функции которой сообщается что сделать с каждым элементом контейнера и сам контейнер, результатом будет отображенный контейнер. Другая строна будет рассмотрена далее.
"f a" в определении обозначает контейнер типа "а". Аналог на с++ будет:
template<class a>
class f ....

Это может быть 
списком целочисленных значений
деревом значений с плавающей точкой
или любой другой произвольной структурой имеющей (kind * -> *). 
(kind * -> *) означает, что "f" будет применен к одному типу.
Если проводить аналогию с с++ - это класс имеющий 1 шаблон.

Таким образом нельзя реализовать класс функтор базовыми типами вроде символов, целочисленных значений, дробей и тд.

К примеру имеется строка(в хаскеле это список символов) и необходимо получить список аски кодов этой строки. Определение этой функции будет следующим:
stringToAscii = fmap ord

Т.е. к каждому элементу списка была применена функция перевода символа в целочисленное значение(ord), представляющее его аски-код

Подобным образом можно отображать массивы, деревья, множества и тд.

Функтором может быть не только контейнер. Функция - тоже является функтором. В таком случае, применяя fmap, будет отображен результат функции, т.е. fmap реализована как композиция:

instance Functor ((->) r)
    fmap = (.)

-- Законы функтора
Любой функтор должен подчиняться следующим законам:
fmap id = id
fmap (g . h) = fmap g . fmap h

Эти законы будут гарантировать что функция будет применена только к элементам и не изменит структуры. К примеру если fmap будет не только отображать список, но и обращать его либо изменять кол-во элементов, эти законы не будут удовлетворены.<<1>>


С другой стороны
fmap  - это функция примимающая (функцию, отображающую один произвольный тип а в другой произвольный тип b)
и возвращающая (функцию отображающую этот контейнер содержащий тип а в этот же контейнер содержащий тип b).
Т.е. поднимает функцию в новый контекст
Мы может переписать определение типа fmap<<2>>:
fmap :: (a -> b) -> (f a -> f b)

Само понятие функтора пришло из теории категорий и имеет следующее определение:
Пусть имеем категорию C и категорию D, тогда функтор F:C -> D
-отображает все объекты А категории С в объекты F(A) категории D
-отображает все морфизмы f:A -> B категории С в морфизмы F(f): F(A) -> F(B) категории D
В таком русле функторы хаскеля отображают категорию Hask в подкатегорию Hask, определенную только на типах функтора.<<3>>

--------------------------------------------------------------------------------
-- Applicative 
Аппликативный функтор добавляет возможность
1)поднять значение в контекст по умолчанию. Например создать список с единственным элементом для списков.
2)применить функцию в контексте к значению в контексте.

Определение:
class Functor f => Applicative f where
    pure :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b

Из Applicative легко вывести Functor:
fmap = (<*>) . pure
Кстати, это один из законов Applicative.
Второй закон:
fmap g . pure = pure . g
Его выполнение гарантируется системой типов:
Т.е. нет способа его нарушить, с учетом корректности fmap

Такое обобщение функтора позволяет, например, применять функцию к нескольким аргументам:
pure (+) <*> [0..2] <*> [3..5]

--------------------------------------------------------------------------------
-- Класс категорий

Определим понятие категории(Определение из теории категорий)
Категория С - это:
-множество объектов ob(C)
-Для любой пары A B : A <- ob(C), B <- ob(C) задано множество морфизмов Hom(A,B),
причём каждому морфизму соответствуют единственные A и B;
-Для каждой пары морфизмов f<-Hom(A,B), g<-Hom(B,C) определена композиция g . f <- Hom(A, C)
-Для каждого объекта А<-ob(C) задан тождественный морфизм ida <- Hom(A, A)
Аксиомы:
  композиция ассоциативна: f . g . h = (f . g) . h
  тождественный морфизм действует тривиально: f . id = id . f = f

В хаскеле же это выглядит следующим образом:

class Category cat where
	  id :: cat a a
	  (.) :: (cat b c) -> (cat a b) -> (cat a c)

Конструктор типа, реализующий класс Категорий должен иметь kind * -> * -> *.

Функция является категорией:

instance Category (->) where
		 id  = Prelude.id
		 (.) = (Prelude..)

Состовляя категорию Hask<<3>>

--------------------------------------------------------------------------------
-- Monoid
 Моноид - множество M, на котором задана бинарная ассоциативная операция и в котором существует такой элемент e, что ex = x = xe для любого x <- M.
Элемент e называется единицей, причем единица единственна.
Т.е. чтобы определить моноид в хаскеле, необходимо задать эту операцию и единицу:

class Monoid a where
        mempty  :: a
        -- ^ Единица

        mappend :: a -> a -> a
        -- ^ Ассоциативная операция

 Многие моноиды определены в Data.Monoid
Например список, хранящий произвольный тип задана как конкатенация и пустой список:
instance Monoid [a] where
        mempty  = []
        mappend = (++)

Int не определен как моноид(программист может сделать это сам),
ведь для целых чисел моноид может быть реализован как умножение с единицей 1 
или сложением с единицей 0. Для этого есть обертки:
Sum 2     `mappend` Sum 3		= Sum 5
Product 2 `mappend` Product 3	= Product 6

--------------------------------------------------------------------------------
--------------------   Определенные пользователем классы   ---------------------
--------------------------------------------------------------------------------
-- Класс Group
 Группа - это моноид имеющий возможность обращать элемент. Т.е. для каждого
элемента x из M(множества, на котором определен моноид) существует элемент y из M, такой что xy = e.

Определим этот класс следующим образом:

class Monoid a => Group a where
    gnegate :: a -> a
    gnegate = (mempty `rmappend`)

    rmappend :: a -> a -> a
    rmappend x y = x `mappend` gnegate y

группа это всегда моноид, поэтому стоит ограничение (Monoid a => )
Он имеет 2 метода определенные друг через друга, необходимо дать определение
одному из них. 

Примером групп могут служить целые числа с операцией (+) и обращением как изменение знака с единицей 0.
Или рациональные с делением и 1 соответственно.

Этот класс необходим в модуле Window, тк позволяет откатывать изменения.
В частности для агрегирующих оконных функций, когда значение перестает быть актуальным. 
Например, если необходимо выбрать последние n записей. В таком случае каждая новая запись заменяет самую старую, но нет необходимости хранить все записи. И более того, пересчет результата происходит за O(1) времени и O(n) памяти.




--------------------------------------------------------------------------------
-- Класс Relation

Класс Relation представляет собой тип данных таблица, отношение.
Методы класса - примитивы реляционной алгебры и другие полезные операции над отношениями.
Описание некоторых из них:

selection - Фильтрует таблицу согласно предикату. Как filter в модулях Seq, Set и тд. Соответствует WHERE в sql.
  В реляционной алгебре представляет собой унарную операцию:
 σaθb(R) или σaθv(R), где 
 -а и b  имена атрибутов
 -бинарная операция из множества{ <, <=, =, >=, > }
 -v константа
 -R отношение

union - объединяет 2 отношения с одинаковыми типами(иначе и не получиться). Объединение ассоциативно, вместе с rempty образует моноид

minus - разность 2х отношений. Фильтр первого отношения по неравенству каждому элементу из второго.

insert - вставка записи в конец отношения
rempty - пустое отношение
joinG - декартово произведение 2х отношений. Принимает также предикат по которому фильтровать и функцию объединения.

Не в классе:
CartProduct - Картезианское произведение
Картезианское произведение R × S определено как:
R × S = {(r1, r2, ..., rn, s1, s2, ..., sm) | (r1, r2, ..., rn) ∈ R, (s1, s2, ..., sm) ∈ S} 
projection - отображение каждого элемента через функцию. fmap - это в точности то что нужно, поэтому стоит ограничение:
(Functor) => ... Т.е. projection - синоним fmap.
Т.е. Следующая унарная операция::

Pia1,.., an(R) = { t[a1,..an] : t ∈ R }
где t[a1,...,an] ограничение кортежа t до {a1,...,an}


--------------------------------------------------------------------------------
-- Класс TupleConcat
Класс для конкатенации разных размеров кортежей. Т.е. конкатенация (a, b) и (c, d) даст (a, b, c, d)
Очень похоже на си++-подобный полиморфизм.

--------------------------------------------------------------------------------
-- Класс TupleApply
Класс, позволяющий применять кортеж функций к аргументу, получая кортеж аргументов.

--------------------------------------------------------------------------------
-- Класс Queue
Небольшой класс, требующий существования пустой очереди, операции вставки и 
изъятия с удалением: 

class Queue f where
    qempty :: f a
    qpush  :: f a -> a -> f a
    qpop   :: f a -> (f a, a)



--------------------------------------------------------------------------------
-------------------------------     RelMap     ---------------------------------
--------------------------------------------------------------------------------

Структура RelMap представляет собой контейнер типа outp и функцию типа
inp -> RelMap inp outp, т.е. принимающий запись, и производящий новый
RelMap.(т.к. в хаскеле данные не изменяемы)
Т.е. функция производит новые данные "изменяя" старый контейнер.
Но контейнер не упомянут в сигнатуре типа rmMapper - подразумевается, что
копия контейнера хранится в замыкании.

data RelMap inp outp = RM
    { rmMapper 	:: inp -> RelMap inp outp
    , rmAcc	    :: Seq outp
    }

Абстрактно, представляет собой тип данных, преобразующий входной поток в выходной.
Необходим способ композиции таких типов данных, поэтому реализация класса категорий - то 
что нужно. 

Сам тип данных тоже может рассматриваться как поток по outp, поэтому он реализует
Relation, Functor, Applicative.

Вообще говоря следует обобщить  такой тип данных до

data RelMapGen f inp outp = RM
    { rmMapper 	:: inp -> RelMapGen f inp outp
    , rmAcc	:: f outp
    }

Где f - произвольный контейнер, реализующий класс Queue(очередь)
В основном такое обобщение необходимо для эффективной реализации 
АПИ модуля Window.lhs, обобщенный вариант композиции в частности.

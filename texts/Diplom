 Введение. Постановка целей, задач, актуальность, новизна (на стыке двух актуальных областей БД и ФП)
1 Обзор смежных областей.
1.1 Технологии баз данных.
1.1.1 Задачи, решаемые базами данных.
1.1.2 Классификация БД.
1.2 Тенденции процессоростроения. Высокая производительность, локальность, многоядерность, распределенность.
1.3 ФП, неизменяемое состояние, ленивые вычисления. Полезные мат. свойства и что они дают при реализации БД. Ассоциативность, коммутативность, идемпотентность. Моноиды, группы.
2 Проектирование системы.
2.1 Постановка задачи. Можно реальный пример GPS или обобщенный. Спецификация требований к пропускной способности и задержкам.
2.2 Анализ доступных на рынке аппаратных средств на соответствие требованиям и их стоимости. CPU, RAM, HDD, SDD, Ethernet. Несколько вариантов компоновки системы. Обоснованный выбор среди них.
2.3 Выбор инструментов: языков, компиляторов, библиотек.
2.4 Подбор алгоритмов и структур данных. Несколько вариантов: на моноидах и группах.
3 Реализация. Внутренние интерфейсы.
3.1 Классы: стандартные, определенные пользователем.
3.2 Структуры: RelMap
3.3 Окна.
3.3.1 на моноидах 
3.3.2 на группах
4 Тестирование на соответствие требованиям. Графики, сравнения.
Заключение. Достигнуты ли цели.
Список использованных источников

1.1 Технологии баз данных.
С начала 60-х годов в информационных технологиях начало формироваться новое направление, актуальность которого обуславливали растущие потребности в создании систем эффективного хранения и обработки больших объемов сложно структурированных данных. К настоящему времени это направление представляет собой обширную и бурно развивающуюся область современной прикладной науки – технологии баз данных.
 Наибольшую популярность получил т. н. реляционный подход и реляционные СУБД, SQL в частности, которые в настоящее время являются основой большинства информационных систем, реализующих функции хранения и обработки данных. Популярность SQL обусловлена многими причинами, такими как:
 стандартизация - наличие стандартов стабилизирует язык, как следствие,
 независимость от конкретного СУБД - тексты запросов достаточно переносимы и тем лучше, чем ближе к стандарту написаны
 декларативность - декларативность позволяет сосредоточится на задаче, абстрагируясь от деталей, позволяя СУБД оптимизировать запрос.

1.1.1 Задачи, решаемые базами данных.
...

1.1.2 Классификация БД.
Классификация БД по модели данных:  иерархические,  сетевые,  реляционные,  объектные,  объектно-ориентированные,  объектно-реляционные. Подробнее:
 Информация в иерархической базе организована по принципу древовидной структуры, в виде отношений предок/потомок. Каждая запись может иметь не более одной родительской записи и несколько подчиненных. Связи записей реализуются в виде физических указателей с одной записи на другую. Основной недостаток иерархической структуры базы данных - невозможность реализовать отношения "многие ко многим", а также ситуации, когда запись имеет несколько предков. 
Сетевая структура баз данных появилась как развитие иерархической. Надо подчеркнуть, что термин "сетевая" употребляется здесь в совсем непривычном для эпохи интернета/интранета смысле. Это слово подчеркивает модель связей данных в базе, когда каждая запись может находиться в отношениях "многие ко многим" с другими записями, что делает графическую модель базы похожей на рыбацкую сеть. Разрабатывать серьезные приложения в рамках сетевой модели базы данных довольно трудно, причем сложность разработки при усложнении задач возрастает в геометрической прогрессии. 
 В реляционных базах данные хранятся в виде таблиц, состоящих из строк и столбцов. Столбцы таблиц реляционной базы могут содержать скалярные данные фиксированного типа - числа, строки, даты... Таблицы в реляционной базе данных могут быть связаны отношениями "один к одному" или "один ко многим". 
Объектно-ориентированные базы данных (ООБД) появились совсем недавно как естественное развитие объектно-ориентированных языков программирования. На сегодняшний день ООБД пока не имеют сколько-нибудь широкого распространения, но, несомненно, они в ближайшее время будут бурно развиваться. Это подтверждает и тот факт, что разработчики многих реляционных БД включают в свои базы средства работы с объектными типами данных. Такие базы данных получили название объектно-реляционных. 



1.2 Тенденции процессоростроения. Высокая производительность, локальность, многоядерность, распределенность.
 Согласно закону Мура число транзисторов на кристалле будет удваиваться приблизительно каждые 2 года. Благодаря этому также достигается постоянное увеличение производительности и энергосбережения.
 Однако на данный момент теоретический предел производительности одного ядра процессора практически достигнут. И вроде бы закон Мура по прежнему продолжает действовать, но теперь он не означает роста производительности. Процессоры, если можно так выразиться, стали расти "вширь", на одном кристалле стали размещать несколько ядер, и число этих ядер неуклонно растет. Но производительность одного ядра почти не увеличивается, что, с точки зрения разработки довольно печально. Если ранее разработчики получали так называемые "дивиденды Мура", или еще это называют "free lunch", за счет того, что давным-давно написанная программа при выходе более нового процессора автоматически начинала работать быстрее. Теперь же, когда вектор изменился и вместо роста производительности одного ядра происходит рост количества ядер, старая однопоточная программ не начнет работать быстрее, если ее запустить на новом, двух/четырехядерном процессоре вместо одноядерного. 
 Однако, параллельные приложения сложно тестировать, отлаживать, проверять их функциональную корректность, появляется новый класс ошибок, связанных именно с параллельностью и т. д.


1.3 ФП, неизменяемое состояние, ленивые вычисления. Полезные мат. свойства и что они дают при реализации БД. Ассоциативность, коммутативность, идемпотентность. Моноиды, группы.
Функциональное программирование предоставляет в этом плане очень богатые возможности. Прежде всего, в функциональной парадигме нет изменяемых структур и, как следствие, нет разделяемого состояния, а значит, уходит одна из главных проблем параллелизма – совместный доступ к ресурсам.
Как следствие, каждая функция зависит только от входных параметров, и результатом ее работы являются только выходные параметры. Такой подход практически на корню снимает проблемы синхронизации. Другое преимущество функциональности заключается в том, что функциональная программа является, по сути, декларативной, то есть описывается не пошаговая реализация алгоритма, а то, что хочется получить в конечном итоге.
Декларативность дает гораздо больше свободы оптимизатору/компилятору, в том числе и по распараллеливанию алгоритма. 
Таким образом, это еще один шажок в сторону усугубления автоматического использования всех доступных мощностей.
 Ленивые вычисления не являются прерогативой функциональных языков - они частично встречаются в императивных языках, например в си/си++, java операторы && ||являются ленивыми. Но в ленивых функциональных языках все функции и структуры данных являются ленивыми, если не указано обратное(такое часто используется для оптимизации, где ленивость оказывается дороже, а также где важен порядок вычислений, например в случае ввода-вывода).
 Нормальный порядок вычисления(ленивое применение аргументов к функции) позволяет вводить в язык макросо-подобные конструкции, которые будучи функциями остаются первоклассными объектами и, как следствие, их все ещё можно использовать как аргументы функции. К примеру тот же && нельзя использовать в функциях высоких порядков, если оператор && сам не является функцией.
 Ленивые вычисления позволяют оперировать с достаточно большими или даже бесконечными объектами причем так, что будет посчитана лишь та часть, которая действительно требуется.
Очень удобно, например считать весь файл в строку и оперировать со строкой, решая прикладную задачу, а компилятор позаботиться о лишних ненужных итерациях и файловых дескрипторах.
  ...
  ...
  ...


2 Проектирование системы.
2.1 Постановка задачи. Можно реальный пример GPS или обобщенный. Спецификация требований к пропускной способности и задержкам.
 Цель проекта - реализация программного интерфейса приложения, благодаря которому можно решать задачи мягкие в режиме реального времени в удобной, декларативной форме. Задача сводилась к реализации потоковой базы данных - такой базы данных, которая оперирует не статическим набором данных, а потоком данных. Соответственно запросы должны быть статическими - функциями(часто агрегирующими), которые способны преобразовывать один поток данных в другой. 
Предполагается что поток данных будет до 10 000 входящих данных в секунду.
2.2 Анализ доступных на рынке аппаратных средств на соответствие требованиям и их стоимости. CPU, RAM, HDD, SDD, Ethernet. Несколько вариантов компоновки системы. Обоснованный выбор среди них.
...
...
...
2.3 Выбор инструментов: языков, компиляторов, библиотек, расширений.
 В качестве языка программирования был выбран Haskell, реализация GHC.
Haskell — стандартизованный чистый(чистота функций гарантируется компилятором) функциональный язык программирования общего назначения. Является одним из самых распространённых языков программирования с поддержкой отложенных вычислений. Типизация в Хаскеле строгая, статическая, с автоматическим выводом типов. Строгая типизация с выводом типов позволяет разрабатывать надежные и корректные программы, бОльшая часть багов будет отловлена на стадии компиляции. Существуют средства автоматического тестирования, отладки и профилирования, в том числе для параллельных программ. Возможность их существования является следствием чистоты языка. 
 Кроме декларативности следует отметить достаточно высокую производительность кода, скомпилированного GHC. По результатам бенчмарков shootout'а GHC оказался на уровне C#. 
 Что касается использованных библиотек стоит отметить в первую очередь Data.FingerTree и частный случай этой структуры данных - Data.Sequence. Были полезны также Data.Tuple.All для обобщенной работы с разными по размеру кортежами.
 Полезным оказалось расширение TemplateHaskell похожее на макросы лиспа, которое позволяет генерировать(и даже обрабатывать и преобразовывать) AST хаскеля на стадии компиляции, что означает генерацию любого количества любых определений(функций, классов, сущностей и тд).


2.4 Подбор алгоритмов и структур данных. Несколько вариантов: на моноидах и группах.
 Было реализовано несколько вариантов оконных функций.
  Решение группами подразумевало что аргрегатор по которому необходимо сворачивать данные будет группой. Решение довольно прямое - каждый новый элемент, попавший в окно умножать по моноиду на аккумулятор, производя новый аккумулятор, а каждый элемент оказавшийся за пределами окна - обращать и вновь умножать по моноиду на аккумулятор, производя новый аккумулятор.
Учитывая, что класс групп более узок, чем класс моноид, решение требующее групп менее гибко по сравнению с решением, требующим моноид.
  Решение моноидами, с другой стороны, более эффективно(особенно это проявляется при частых запросах), более гибко.
В этом случае было использовано Finger Tree -  дерево, которое хранит частичные решения - частичные свертки моноидов. Каждый новый элемент(не зависимо ни от чего) добавляется в конец дерева(O(1)), а при запросе выделяется нужное окно(O(ln n)) и считается нужный моноид. Если не было запроса - ничего лишнего посчитано не будет благодаря лени.(Более подробно описано в комментариях в файле ./sandbox/2/Relations/Window.lhs)


 В пакете Data.FingerTree структура FingerTree определена следующим образом(восклицательные 
знаки указывают на то что значение хранится строго - не лениво, т.е. при применении 
конструктора сначала будут вычислены аргументы):
data FingerTree v a
	= Empty
	| Single a
	| Deep !v !(Digit a) (FingerTree v (Node v a)) !(Digit a)
data Node v a = Node2 !v a a | Node3 !v a a a
	deriving Show
data Digit a
    = One a
    | Two a a
    | Three a a a
    | Four a a a a
    deriving Show

Т.о. FingerTree хранящее элементы типа "а" - это дерево, которое хранит:
- либо ничего
- либо единственный элемент типа "а"
- либо структуру:
     - от 1 до 4 элементов типа "а" слева
	 - FingerTree хранящее элементы типа (2 или 3 элемента типа "а")
     - от 1 до 4 элементов типа "а" справа

Значение "v" не имеет прямого отношения к структуре дерева.
Предполагается, что любое значение "а" может быть вычислено в моноид "v"(Т.е. "измерено")
-- | Things that can be measured.
class (Monoid v) => Measured v a | a -> v where
    measure :: a -> v

Хранение значения v дает возможность за O(1) получить значение свернутого дерева, 
где каждый элемент дерева отображен через функцию measure.

Кроме этого, чем ещё хороша такая структура?
 -Вставка элемента в конец/начало за O(1)
 -Конкатенация 2х деревьев за O(log(min(n1,n2)))
 -Деструктурирование на (первый : остальные) за O(1)
 -Деструктурирование на (последний : всеКромеПоследнего) за O(1)
 -Разбиение по предикату на 2 поддерева за O(log(min(n1,n2)))

 Допустим необходимо ограничиться окном "данные за последний час", тогда все что 
нужно сделать - это определить measure как функцию, которая вычисляет время из 
записи(все входящие данные Timable, поэтому эта задача не составит труда), и возвращает время обернутое стандартным 
моноидом Data.Monoid.Last
 Если нужно по количеству записей, то measure будет возвращать моноид Sum 1.
Разумеется можно брать произвольно ограниченное окно. Подробнее расписано в Window.lhs

Небольшая иллюстрация того, как работает дерево может быть:
./GPS-stream/sandbox/FingerTreeViewer/FTViewer.hs
Лог использования в файле:
./GPS-stream/sandbox/FingerTreeViewer/log.txt


3 Реализация. Внутренние интерфейсы.
3.1 Классы: стандартные, определенные пользователем
--------   Стандартные  классы   ---------
-- Классы Show, Read

Любой тип, реализующий класс Show может быть преобразован в строку. Это и отражено в определении:

class Show a where
    show      :: a -> String
    showsPrec :: Int -> a -> ShowS
    showList  :: [a] -> ShowS

У каждого класса имеется минимальное полное определение. В данном случае это show или showsPrec. Это означает, что остальные методы могут быть реализованы с помощью определенных методов(хотя и для эффективности могут быть определены программистом явно). Определения по умолчанию Show:
    show x          = showsPrec 0 x ""
    showsPrec _ x s = show x ++ s
Т.к. оба метода определены друг через друга, не определив ни один метод, попадем в бесконечную взаимную рекурсию.

тип ShowS это просто синоним функции из строки в строку:
type ShowS = String -> String

Аналогично и
class Read a where
    readsPrec :: Int -> ReadS a
    readList  :: ReadS [a]
минимальное полное определение: readsPrec

тип ReadS это функция принимающая строку, возвращающая список возможных способов разбора тип данных и оставшихся после этого строк:
type ReadS a = String -> [(a, String)]

Эти классы используются, как правило, для целей ввода-вывода и представляют собой человеко-читабельную сериализацию.
Для большинства пользовательских классов они могут быть определены автоматически.

-- Класс Functor
 Класс представляет собой контейнер, такой что к каждому элементу контейнера может быть применена функция.
Посмотрим на определение:

class Functor f where
    fmap :: (a -> b) -> f a -> f b

С одной стороны можно думать как о функции которой сообщается что сделать с каждым элементом контейнера и сам контейнер, результатом будет отображенный контейнер. Другая строна будет рассмотрена далее.
"f a" в определении обозначает контейнер типа "а". Аналог на с++ будет:
template<class a>
class f ....

Это может быть 
списком целочисленных значений
деревом значений с плавающей точкой
или любой другой произвольной структурой имеющей (kind * -> *). 
(kind * -> *) означает, что "f" будет применен к одному типу.
Если проводить аналогию с с++ - это класс имеющий 1 параметр шаблона.

Таким образом нельзя реализовать класс функтор базовыми типами вроде символов, целочисленных значений, дробей и тд.

К примеру имеется строка(в хаскеле это список символов) и необходимо получить список аски кодов этой строки. Определение этой функции будет следующим:
stringToAscii = fmap ord

Т.е. к каждому элементу списка была применена функция перевода символа в целочисленное значение(ord), представляющее его аски-код

Подобным образом можно отображать массивы, деревья, множества и тд.

Функтором может быть не только контейнер. Функция - тоже является функтором. В таком случае, применяя fmap, будет отображен результат функции, т.е. fmap реализована как композиция:

instance Functor ((->) r)
    fmap = (.)

-- Законы функтора
Любой функтор должен подчиняться следующим законам:
fmap id = id
fmap (g . h) = fmap g . fmap h

Эти законы будут гарантировать что функция будет применена только к элементам и не изменит структуры. К примеру если fmap будет не только отображать список, но и обращать его либо изменять кол-во элементов, эти законы не будут удовлетворены.


С другой стороны
fmap  - это функция примимающая (функцию, отображающую один произвольный тип а в другой произвольный тип b)
и возвращающая (функцию отображающую этот контейнер содержащий тип а в этот же контейнер содержащий тип b).
Т.е. поднимает функцию в новый контекст
Мы может переписать определение типа fmap:
fmap :: (a -> b) -> (f a -> f b)

Само понятие функтора пришло из теории категорий и имеет следующее определение:
Пусть имеем категорию C и категорию D, тогда функтор F:C -> D
-отображает все объекты А категории С в объекты F(A) категории D
-отображает все морфизмы f:A -> B категории С в морфизмы F(f): F(A) -> F(B) категории D
В таком русле функторы хаскеля отображают категорию Hask в подкатегорию Hask, определенную только на типах функтора.

-- Applicative 
Аппликативный функтор добавляет возможность
1)поднять значение в контекст по умолчанию. Например создать список с единственным элементом для списков.
2)применить функцию в контексте к значению в контексте.

Определение:
class Functor f => Applicative f where
    pure :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b

Из Applicative легко вывести Functor:
fmap = (<*>) . pure
Кстати, это один из законов Applicative.
Второй закон:
fmap g . pure = pure . g
Его выполнение гарантируется системой типов:
Т.е. нет способа его нарушить, с учетом корректности fmap

Такое обобщение функтора позволяет, например, применять функцию к нескольким аргументам:
pure (+) <*> [0..2] <*> [3..5]

-- Класс категорий

Определим понятие категории(Определение из теории категорий)
Категория С - это:
-множество объектов ob(C)
-Для любой пары A B : A <- ob(C), B <- ob(C) задано множество морфизмов Hom(A,B),
причём каждому морфизму соответствуют единственные A и B;
-Для каждой пары морфизмов f<-Hom(A,B), g<-Hom(B,C) определена композиция g . f <- Hom(A, C)
-Для каждого объекта А<-ob(C) задан тождественный морфизм ida <- Hom(A, A)
Аксиомы:
  композиция ассоциативна: f . g . h = (f . g) . h
  тождественный морфизм действует тривиально: f . id = id . f = f

В хаскеле же это выглядит следующим образом:

class Category cat where
	  id :: cat a a
	  (.) :: (cat b c) -> (cat a b) -> (cat a c)

Конструктор типа, реализующий класс Категорий должен иметь kind * -> * -> *.

Функция является категорией:

instance Category (->) where
		 id  = Prelude.id
		 (.) = (Prelude..)

Состовляя категорию Hask

-- Monoid
 Моноид - множество M, на котором задана бинарная ассоциативная операция и в котором существует такой элемент e, что ex = x = xe для любого x <- M.
Элемент e называется единицей, причем единица единственна.
Т.е. чтобы определить моноид в хаскеле, необходимо задать эту операцию и единицу:

class Monoid a where
        mempty  :: a
        -- ^ Единица

        mappend :: a -> a -> a
        -- ^ Ассоциативная операция

 Многие моноиды определены в Data.Monoid
Например список, хранящий произвольный тип задана как конкатенация и пустой список:
instance Monoid [a] where
        mempty  = []
        mappend = (++)

Int не определен как моноид(программист может сделать это сам),
ведь для целых чисел моноид может быть реализован как умножение с единицей 1 
или сложением с единицей 0. Для этого есть обертки:
Sum 2     `mappend` Sum 3		= Sum 5
Product 2 `mappend` Product 3	= Product 6

------   Определенные пользователем классы   --------
-- Класс Group
 Группа - это моноид имеющий возможность обращать элемент. Т.е. для каждого
элемента x из M(множества, на котором определен моноид) существует элемент y из M, такой что xy = e.

Определим этот класс следующим образом:

class Monoid a => Group a where
    gnegate :: a -> a
    gnegate = (mempty `rmappend`)

    rmappend :: a -> a -> a
    rmappend x y = x `mappend` gnegate y

группа это всегда моноид, поэтому стоит ограничение (Monoid a => )
Он имеет 2 метода определенные друг через друга, необходимо дать определение
одному из них. 

Примером групп могут служить целые числа с операцией (+) и обращением как изменение знака с единицей 0.
Или рациональные с делением и 1 соответственно.

Этот класс необходим в модуле Window, тк позволяет откатывать изменения.
В частности для агрегирующих оконных функций, когда значение перестает быть актуальным. 
Например, если необходимо выбрать последние n записей. В таком случае каждая новая запись заменяет самую старую, но нет необходимости хранить все записи. И более того, пересчет результата происходит за O(1) времени и O(n) памяти.


-- Класс Relation

Класс Relation представляет собой тип данных таблица, отношение.
Методы класса - примитивы реляционной алгебры и другие полезные операции над отношениями.
Описание некоторых из них:

selection - Фильтрует таблицу согласно предикату. Как filter в модулях Seq, Set и тд. Соответствует WHERE в sql.
  В реляционной алгебре представляет собой унарную операцию:
 σaθb(R) или σaθv(R), где 
 -а и b  имена атрибутов
 -бинарная операция из множества{ <, <=, =, >=, > }
 -v константа
 -R отношение

union - объединяет 2 отношения с одинаковыми типами(иначе и не получиться). Объединение ассоциативно, вместе с rempty образует моноид

minus - разность 2х отношений. Фильтр первого отношения по неравенству каждому элементу из второго.

insert - вставка записи в конец отношения
rempty - пустое отношение
joinG - декартово произведение 2х отношений. Принимает также предикат по которому фильтровать и функцию объединения.

Не в классе:
CartProduct - декартово произведение
декартово произведение R × S определено как:
R × S = {(r1, r2, ..., rn, s1, s2, ..., sm) | (r1, r2, ..., rn) ∈ R, (s1, s2, ..., sm) ∈ S} 
projection - отображение каждого элемента через функцию. fmap - это в точности то что нужно, поэтому стоит ограничение:
(Functor) => ... Т.е. projection - синоним fmap.
Т.е. Следующая унарная операция::

Pia1,.., an(R) = { t[a1,..an] : t ∈ R }
где t[a1,...,an] ограничение кортежа t до {a1,...,an}

-- Класс TupleConcat
Класс для конкатенации разных размеров кортежей. Т.е. конкатенация (a, b) и (c, d) даст (a, b, c, d)
Очень похоже на си++-подобный полиморфизм.

-- Класс TupleApply
Класс, позволяющий применять кортеж функций к аргументу, получая кортеж аргументов.

-- Класс Queue
Небольшой класс, требующий существования пустой очереди, операции вставки и 
изъятия с удалением:

class Queue f where
    qempty :: f a
    qpush  :: f a -> a -> f a
    qpop   :: f a -> (f a, a)


3.2 Струкрута RelMap

Структура RelMap представляет собой контейнер типа outp и функцию типа
inp -> RelMap inp outp, т.е. принимающий запись, и производящий новый
RelMap.(т.к. в хаскеле данные не изменяемы)
Т.е. функция производит новые данные "изменяя" старый контейнер.
Но контейнер не упомянут в сигнатуре типа rmMapper - подразумевается, что
копия контейнера хранится в замыкании.

data RelMap inp outp = RM
    { rmMapper 	:: inp -> RelMap inp outp
    , rmAcc	    :: Seq outp
    }

Абстрактно, представляет собой тип данных, преобразующий входной поток в выходной.
Необходим способ композиции таких типов данных, поэтому реализация класса категорий - то 
что нужно. 

Сам тип данных тоже может рассматриваться как поток по outp, поэтому он реализует
Relation, Functor, Applicative.

Обобщенно, такой тип данных выглядит так:

data RelMapGen f inp outp = RM
    { rmMapper 	:: inp -> RelMapGen f inp outp
    , rmAcc	:: f outp
    }

Где f - произвольный контейнер, реализующий класс Queue(очередь)
В основном такое обобщение необходимо для эффективной реализации 
АПИ модуля Window.lhs, обобщенный вариант композиции в частности. Он позволит применять композиции к нескольким RelMapGen с разными типами контейнеров.

Такой тип данных достаточно очевидным образом реализует класс категорий:

instance (Queue f, Foldable f) => Category (RelMapGen f) where
    id = RM (mkMapper qempty) qempty
        where mkMapper acc inp = RM (mkMapper acc) (acc `qpush` inp)
    (.) = rmComp

rmComp :: (Foldable f) => RelMapGen g b c -> RelMapGen f a b -> RelMapGen g a c
rm2@(RM fn2 acc2) `rmComp` rm1@(RM fn1 acc1) = RM fn3 acc3
    where fn3 inp 	= rm2 `rmComp` fn1 inp
          acc3	 	= rmAcc $ feedElms rm2 acc1

Т.е. композиция представляет собой поэлементную передачу всех элементов контейнера второго аргумента RelMapGen функции первого аргумента RelMapGen.
Единичный элемент - просто накопитель.

Также можно производить операции над потоками: объединение, декартово произведение и др. Это гарантируется классом Relation.

3.3 Окна.
3.3.1 На моноидах:

>newtype Acc a = Acc { getAcc :: a } deriving(Show)
Единственной целью типа-обертки Acc является сделать возможным хранения обернутого моноида в
FingerTree. FingerTree требует Measured, поэтому пара (UTCTime, Acc a) реализует Measured

window' принимает 
 -2 ограничителя: по времени и по количеству записей
 -функцию из записи в моноид

возвращаемое значение - это отображение отношений, которое хранит результат в FingerTree
Служебное поля FingerTree (Max UTCTime, Sum Int, b) позволяет быстро находить необходимые окна
исходя из текущего времени и количества записей.

Каждое полученное значение добавляется в аккумулятор, 
геттер аккумулятора - просто фильтрует дерево функцией restrictFT

ограничители представляют собой
 1)функцию от текущего времени во временные рамки
 2)функцию от количества в пару (начинаяСИндекса, количествоЗначений). Именно количествоЗначений, 
    а не заканчиваяИндексом, тк семантика restrictFT представляет собой (dropUntil _ . takeUntil _),
    а FingerTree пересчитывает моноид после разбиения (dropUntil и takeUntil это как раз разбиение)

>window'
>  :: (Timable a, Monoid b) =>
>     Maybe (UTCTime -> (UTCTime, UTCTime))
>  -> Maybe (Int -> (Int, Int))
>  -> (a -> b)
>  -> RelMapGen
>     (FingerTree (Max UTCTime, Sum Int, b)) a (UTCTime, Acc b)
>window' tRestr cRestr fn = restrictor where
...

windowAggr, window - две похожие функции, с той разницей, что 
windowAggr сворачивает результат(окно) по моноиде, соответственно
windowAggr в отличии от window имеет ограничение (Monoid b)

имея служебное поле FingerTree "(Max UTCTime, Sum Int, b)"
windowAggr обращается к "b" из служебного поля, который и содержит необходимый результат.
Т.к. каждое поддерево хранит частичный результат свертки моноида, 
пересчет результата при следующем запросе будет очень быстр.(быстрее чем за O(ln n))

Итого:
 добавления элемента - О(1), 
 выделение нужного окна не превысит O(ln n), 
    а точнее O(ln ((min (i, n) + min (n, j)))), 
    где n, i, j - размеры окна, остатка слева, остатка справа соответственно 

>windowAggr
>  :: (Timable a, Monoid b) =>
>     Maybe (UTCTime -> (UTCTime, UTCTime))
>  -> Maybe (Int -> (Int, Int))
>  -> (a -> b)
>  -> RelMap a b
>windowAggr tRestr cRestr fn = fromFn sel3 . (selector $ window' tRestr cRestr fn) where
...

window - просто ограничивает результат, не влияя на записи. чтобы вновь воспользоваться
функцией window' "b" нужно сделать моноидой, поэтому под эту роль сгодиться любой моноид, 
не имеющий ограничений на тип, например First.
Поэтому в функцию window' передадим композицию аргумента-функции и конструктора First,
а результат возьмем напрямую из Just.

>window :: (Timable a) =>
>          Maybe (UTCTime -> (UTCTime, UTCTime))
>       -> Maybe (Int     -> (Int, Int))
>       -> (a -> b)
>       -> RelMap a b
>window tRestr cRestr fn = selector `rmComp` window' tRestr cRestr (First . Just . fn) where
...

>mkFTSelector :: (Timable a, Monoid b) =>
>              (a -> b)
>           -> RelMapGen (FingerTree (Max UTCTime, Sum Int, b)) a (UTCTime, Acc b)
>mkFTSelector fn = RM (mkMapper FT.empty) FT.empty where
...

--------------------------------------

restrictFT - функция, принимающая 2 ограничителя по времени и количеству,
возвращающая отображение FingerTree, а именно, ограничивает окном.

>restrictFT :: (Monoid b) =>
>              Maybe (UTCTime -> (UTCTime, UTCTime))	-- from/to time producer
>           -> Maybe (Int     -> (Int, Int))		-- from/to count producer
>           -> FingerTree (Max UTCTime, Sum Int, b) (UTCTime, Acc b)
>           -> FingerTree (Max UTCTime, Sum Int, b) (UTCTime, Acc b)
>restrictFT restrT restrC inpFT = (FT.takeUntil tPred . FT.dropUntil dPred $ inpFT) where
...

------------------------------------------------------------------------------
Далее просто набор функций, для удобной работы,
способы построить ограничители из Integer, NominalDiffTime и тд

>lastSecs :: Integer -> Maybe (UTCTime -> (UTCTime, UTCTime))
...

>lastPico :: NominalDiffTime -> Maybe (UTCTime -> (UTCTime, UTCTime))
...

>lastRows :: (Num a, Bounded a) => a -> Maybe (a -> (a, a))
...

------------------------------------------------------------------------------
функции для проверки производительности
все функции запускались на 10 000 входящих записях и отрабатывали быстрее чем за полсекунды.
в целом получилось быстрее, чем оптимизация группами. Кроме того для поиска нужного окна 
нужно около O(ln n), поэтому проверки могу быть достаточно ресурсоемкими и это не сильно 
повлияет на общую производительность.

Стоит также отметить, что testAg1 не сильно отличается от testAg2, по затраченному времени,
тк моноид, по которому происходила свертка считался лениво - т.е. при действительном запросе на свернутый моноид,
причем он посчитал свертки всех своих промежуточных узлов - поддеревьев, которые не придется 
считать при следующем обращении. Это дает прирост производительности при частых запросах, а не единичных запросах.
В качестве иллюстрации приведена функции testAg2' и testAg1', которые обрабатывают 20 000 данных и
выполняют запрос каждые 10 000. testAg2' отработала за 0.623249s против testAg1', отработавшей за
0.828081s

4 Тестирование на соответствие требованиям. Графики, сравнения.

 результаты окон на моноидах оказались следующие(rowWind - количество записей в окне = 50, всего 10000 входящих записей):

test - окно без агрегации по количеству записей (~0.40845s):
window Nothing (lastRows rowWind) sel2

testAg1 - агрегатор через композицию (~0.410508s):
window Nothing (lastRows rowWind) (Product . sel2)

testAg1' - 2 агрегатора через композицию (~0.828081s):
window Nothing (lastRows rowWind) (Product . sel2)

testAg2 - агрегатор через функцию windowAggr (~0.422327s)
windowAggr Nothing (lastRows rowWind) (Product . sel2)

testAg2' 2 агрегатора через функцию windowAggr (~0.623249s)
windowAggr Nothing (lastRows rowWind) (Product . sel2)

test1 - окно без агрегации, по времени (~0.416505s)
window (lastPico diff) Nothing (Product . sel2)

Заключение. Достигнуты ли цели.
...
...
...
Список использованных источников
...
...
...

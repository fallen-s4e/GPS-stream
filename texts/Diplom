 Введение. Постановка целей, задач, актуальность, новизна (на стыке двух актуальных областей БД и ФП)
1 Обзор смежных областей.
1.1 Технологии баз данных.
1.1.1 Задачи, решаемые базами данных. Скрыть детали, повысить уровень абстракции. Какой уровень абстракции оптимален, как пришли к SQL и почему к нему.
1.1.2 Классификация и (технологические) причины сегментирования рынка БД. OLTP, OLAP, DSMS.
1.2 Тенденции процессоростроения. Высокая производительность, локальность, многоядерность, распределенность.
1.3 ФП, неизменяемое состояние, ленивые вычисления. Полезные мат. свойства и что они дают при реализации БД. Ассоциативность, коммутативность, идемпотентность. Моноиды, группы.
2 Проектирование системы.
2.1 Постановка задачи. Можно реальный пример GPS или обобщенный. Спецификация требований к пропускной способности и задержкам.
2.2 Анализ доступных на рынке аппаратных средств на соответствие требованиям и их стоимости. CPU, RAM, HDD, SDD, Ethernet. Несколько вариантов компоновки системы. Обоснованный выбор среди них.
2.3 Выбор инструментов: языков, компиляторов, библиотек.
2.4 Подбор алгоритмов и структур данных. Несколько вариантов: на моноидах и группах.
3 Реализация. Внутренние интерфейсы.
4 Тестирование на соответствие требованиям (можно не всю систему, а основных компонентов через внутренние интерфейсы). Графики, сравнения.
Заключение. Достигнуты ли цели.
Список использованных источников


1.2 Тенденции процессоростроения. Высокая производительность, локальность, многоядерность, распределенность.
 Согласно закону Мура число транзисторов на кристалле будет удваиваться приблизительно каждые 2 года. Благодаря этому также достигается постоянное увеличение производительности и энергосбережения.
 Однако на данный момент теоретический предел производительности одного ядра процессора практически достигнут. И вроде бы закон Мура по прежнему продолжает действовать, но теперь он не означает роста производительности. Процессоры, если можно так выразиться, стали расти "вширь", на одном кристалле стали размещать несколько ядер, и число этих ядер неуклонно растет. Но производительность одного ядра почти не увеличивается, что, с точки зрения разработки довольно печально. Если ранее разработчики получали так называемые "дивиденды Мура", или еще это называют "free lunch", за счет того, что давным-давно написанная программа при выходе более нового процессора автоматически начинала работать быстрее. Теперь же, когда вектор изменился и вместо роста производительности одного ядра происходит рост количества ядер, старая однопоточная программ не начнет работать быстрее, если ее запустить на новом, двух/четырехядерном процессоре вместо одноядерного. 
 Однако, параллельные приложения сложно тестировать, отлаживать, проверять их функциональную корректность, появляется новый класс ошибок, связанных именно с параллельностью и т. д.


1.3 ФП, неизменяемое состояние, ленивые вычисления. Полезные мат. свойства и что они дают при реализации БД. Ассоциативность, коммутативность, идемпотентность. Моноиды, группы.
Функциональное программирование предоставляет в этом плане очень богатые возможности. Прежде всего, в функциональной парадигме нет изменяемых структур и, как следствие, нет разделяемого состояния, а значит, уходит одна из главных проблем параллелизма – совместный доступ к ресурсам.
Как следствие, каждая функция зависит только от входных параметров, и результатом ее работы являются только выходные параметры. Такой подход практически на корню снимает проблемы синхронизации. Другое преимущество функциональности заключается в том, что функциональная программа является, по сути, декларативной, то есть описывается не пошаговая реализация алгоритма, а то, что хочется получить в конечном итоге.
Декларативность дает гораздо больше свободы оптимизатору/компилятору, в том числе и по распараллеливанию алгоритма. 
Таким образом, это еще один шажок в сторону усугубления автоматического использования всех доступных мощностей.
 Ленивые вычисления не являются прерогативой функциональных языков - они частично встречаются в императивных языках, например в си/си++, java операторы && ||являются ленивыми. Но в ленивых функциональных языках все функции и структуры данных по умолчанию являются ленивыми, если не указано обратное(такое часто используется для оптимизации, где ленивость оказывается дороже, а также где важен порядок вычислений, например в случае ввода-вывода).
 Нормальный порядок вычисления(ленивое применение аргументов к функции) позволяет вводить в язык макросо-подобные конструкции, которые будучи функциями остаются первоклассными объекми и, как следствие, их все ещё можно использовать как аргументы функции. К примеру тот же && нельзя использовать в функциях высоких порядков, если оператор && сам не является функцией.
 Ленивые вычисления позволяют оперировать с достаточно большими или даже бесконечными объектами причем так, что будет посчитана лишь та часть, которая действительно требуется.
Очень удобно, например считать весь файл в строку и оперировать со строкой, решая прикладную задачу, а компилятор позаботиться о лишних ненужных итерациях и файловых дескрипторах.
  ...
  ...
  ...


2 Проектирование системы.
2.1 Постановка задачи. Можно реальный пример GPS или обобщенный. Спецификация требований к пропускной способности и задержкам.
 Цель проекта - реализация программного интерфейса приложения, благодаря которому можно решать задачи мягкие в режиме реального времени в удобной, декларативной форме. Задача сводилась к реализации потоковой базы данных - такой базы данных, которая оперирует не статическим набором данных, а потоком данных. Соответственно запросы должны быть статическими - функциями(часто агрегирующими), которые способны преобразовывать один поток данных в другой. 
Предполагается что поток данных будет до 10 000 входящих данных в секунду.
2.2 Анализ доступных на рынке аппаратных средств на соответствие требованиям и их стоимости. CPU, RAM, HDD, SDD, Ethernet. Несколько вариантов компоновки системы. Обоснованный выбор среди них.
...
...
...
2.3 Выбор инструментов: языков, компиляторов, библиотек, расширений.
 В качестве языка программирования был выбран Haskell, реализация GHC.
Haskell — стандартизованный чистый(чистота функций гарантируется компилятором) функциональный язык программирования общего назначения. Является одним из самых распространённых языков программирования с поддержкой отложенных вычислений. Типизация в Хаскеле строгая, статическая, с автоматическим выводом типов. Строгая типизация с выводом типов позволяет разрабатывать надежные и корректные программы, бОльшая часть багов будет отловлена на стадии компиляции. Существуют средства автоматического тестирования, отладки и профилирования, в том числе для параллельных программ. Возможность их существования является следствием чистоты языка. 
 Кроме декларативности следует отметить достаточно высокую производительность кода, скомпилированного GHC. По результатам бенчмарков shootout'а GHC оказался на уровне C#. 
 Что касается использованных библиотек стоит отметить в первую очередь Data.FingerTree и частный случай этой структуры данных - Data.Sequence. Были полезны также Data.Tuple.All для обобщенной работы с разными по размеру кортежами.
 Полезным оказалось расширение TemplateHaskell похожее на макросы лиспа, которое позволяет генерировать(и даже обрабатывать и преобразовывать) AST хаскеля на стадии компиляции, что означает генерацию любого количества любых определений(функций, классов, сущностей и тд).


2.4 Подбор алгоритмов и структур данных. Несколько вариантов: на моноидах и группах.
 Было реализовано несколько вариантов оконных функций.
  Решение группами подразумевало что аргрегатор по которому необходимо сворачивать данные будет группой. Решение довольно прямое - каждый новый элемент, попавший в окно умножать по моноиду на аккумулятор, производя новый аккумулятор, а каждый элемент оказавшийся за пределами окна - обращать и вновь умножать по моноиду на аккумулятор, производя новый аккумулятор.
Учитывая, что класс групп более узок, чем класс моноид, решение требующее групп менее гибко по сравнению с решением, требующим моноид.
  Решение моноидами, с другой стороны, более эффективно(особенно это проявляется при частых запросах), более гибко.
В этом случае было использовано Finger Tree -  дерево, которое хранит частичные решения - частичные свертки моноидов. Каждый новый элемент(не зависимо ни от чего) добавляется в конец дерева(O(1)), а при запросе выделяется нужное окно(O(ln n)) и считается нужный моноид. Если не было запроса - ничего лишнего посчитано не будет благодаря лени.(Более подробно описано в комментариях в файле ./sandbox/2/Relations/Window.lhs)

 В пакете Data.FingerTree структура FingerTree определена следующим образом(восклицательные 
знаки указывают на то что значение хранится строго - не лениво, т.е. при применении 
конструктора сначала будут вычислены аргументы):
data FingerTree v a
	= Empty
	| Single a
	| Deep !v !(Digit a) (FingerTree v (Node v a)) !(Digit a)
data Node v a = Node2 !v a a | Node3 !v a a a
	deriving Show
data Digit a
    = One a
    | Two a a
    | Three a a a
    | Four a a a a
    deriving Show

Т.о. FingerTree хранящее элементы типа "а" - это дерево, которое хранит:
- либо ничего
- либо единственный элемент типа "а"
- либо структуру:
     - от 1 до 4 элементов типа "а" слева
	 - FingerTree хранящее элементы типа (2 или 3 элемента типа "а")
     - от 1 до 4 элементов типа "а" справа

Значение "v" не имеет прямого отношения к структуре дерева.
Предполагается, что любое значение "а" может быть вычислено в моноид "v"(Т.е. "измерено")
-- | Things that can be measured.
class (Monoid v) => Measured v a | a -> v where
    measure :: a -> v

Хранение значения v дает возможность за O(1) получить значение свернутого дерева, 
где каждый элемент дерева отображен через функцию measure.

Кроме этого, чем ещё хороша такая структура?
 -Вставка элемента в конец/начало за O(1)
 -Конкатенация 2х деревьев за O(log(min(n1,n2)))
 -Деструктурирование на (первый : остальные) за O(1)
 -Деструктурирование на (последний : всеКромеПоследнего) за O(1)
 -Разбиение по предикату на 2 поддерева за O(log(min(n1,n2)))

 Допустим необходимо ограничиться окном "данные за последний час", тогда все что 
нужно сделать - это определить measure как функцию, которая вычисляет время из 
записи(все входящие данные Timable, поэтому эта задача не составит труда), и возвращает время обернутое стандартным 
моноидом Data.Monoid.Last
 Если нужно по количеству записей, то measure будет возвращать моноид Sum 1.
Разумеется можно брать произвольно ограниченное окно. Подробнее расписано в Window.lhs

Небольшая иллюстрация того, как работает дерево может быть:
./GPS-stream/sandbox/FingerTreeViewer/FTViewer.hs
Лог использования в файле:
./GPS-stream/sandbox/FingerTreeViewer/log.txt


3 Реализация. Внутренние интерфейсы.


4 Тестирование на соответствие требованиям (можно не всю систему, а основных компонентов через внутренние интерфейсы). Графики, сравнения.
Заключение. Достигнуты ли цели.
Список использованных источников
